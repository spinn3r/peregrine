

- Consider an implementation of this sorting algorithm that uses an in-place
  sort on disk with sequential IO which would allow us to use less disk space...

    - I don't really need to because once I'm done with chunks, I can write a
      progress file, delete the previous chunk file, then continue,  This would
      require CHUNK_SIZE additional bytes which isn't the end of the world.
  
- write a few tests of sequential pseudo sequential read and write IO
  performance.  This involved running two writers to two files on a single HDD
  ...

  Test these scenarios:

    - As writes come in , write them to individual files directly.
        - also test with fallocate() or say 500k-5MB extents
        
    - Buffered writes so that we lay them down as individual files but then
      reads have to jump over regions within the file.  This would yield a
      sequential file BUT I would have to seek over large portions of it...

        - 1000 partitions... writing to us in chunks

    










- It COULD be that MapOutputIndex is being corrupted... try to make THAT
  synchronous ... 

- TODO:

    - MapOutputBuffer needs to be synchronized becuase for SOME reason it ends
      up corupted.  This defeats the whole point of being parallel.

    - Unit test to run full map and reduce phase... 


- FIXME: I need to now create some unit tests that verify the correct design:

    - writes to muliple chunk files
    - make sure chunk files get schedule for execution on the correct CPU/thread
    - verify that algorithm execution is correct
        
- The current sort doesn't place things under the same key which is wrong.
