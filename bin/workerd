#!/bin/sh

# When true, always allow the existing daemon to work.
export YIELD_TO_EXISTING_DAEMON=true

start() {

    # first check if we are already running ...
    ./bin/jexec peregrine.worker.WaitForDaemon 2> /dev/null $args 
    result=$?

    # yup... we're up and running, so stop and return.
    if [ "$result" = "0" ] && [ "$YIELD_TO_EXISTING_DAEMON" = "true" ] ; then
        echo "Daemon was already up and listening."
        exit 0
    fi

    # Get the max direct memory we will use.  This can't use GetConfig because
    # there may be multiple variables involved.

    export MAX_DIRECT_MEMORY=$(./bin/jexec peregrine.worker.GetMaxDirectMemory $args 2> /dev/null)
    result=$?

    if [ "$result" != "0" ]; then
        echo "Unable to determine max memory" 
        exit $result
    fi

    # no, we weren't running, so go ahead and startup.

    host=$(./bin/jexec peregrine.worker.GetConfig $args 2> /dev/null |grep host= |grep -Eo '[^=]+$')

    stderr="logs/peregrine-workerd-$host.err"
    stdout="logs/peregrine-workerd-$host.out"
    
    ./bin/jexec peregrine.worker.Main $args < /dev/null > $stdout 2> $stderr &

    pid=$!

    # now that we started the daemon, wait for it to startup... if it starts, great,
    # if not fail.
    ./bin/jexec peregrine.worker.WaitForDaemon --pid=$pid $args 2> /dev/null 
    result=$?

    exit $result

}

stop() {
    
    ./bin/jexec peregrine.worker.Main $args 2> /dev/null
    result=$?

    if [ "$result" != "0" ]; then
        echo "FAILED to stop daemon"
    fi

    exit $result

}

args=$@
shift $(expr $# - 1)
command=$1

case $command in

    start)
        start
        ;;

    stop)
        stop
        ;;

    restart)
        stop
        start
        ;;

    *)
        echo "ERROR: unknown command: $command" 
        exit 1
        ;;

esac
