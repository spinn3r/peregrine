#!/bin/sh

# When true, always allow the existing daemon to work.
export YIELD_TO_EXISTING_DAEMON=true

# Determine how to handle stdout and stderr from the worker daemon.  
#
# none: (default) we write to /dev/null.
# 
# standard: write to standard out and standard err
#
# file: write to .err and .out files.

export OUTPUT=file
export JMX_PORT_OFFSET=1000

start() {

    # first check if we are already running ...
    ./bin/jexec peregrine.worker.WaitForDaemon 2> /dev/null > /dev/null $args 
    result=$?

    # yup... we're up and running, so stop and return.
    if [ "$result" = "0" ] && [ "$YIELD_TO_EXISTING_DAEMON" = "true" ] ; then
        echo "Daemon was already up and listening."
        exit 0
    fi

    export MAX_MEMORY=$(./bin/jexec peregrine.worker.GetConfig $args --getString=maxMemory 2> /dev/null)

    port=$(./bin/jexec peregrine.worker.GetConfig $args --getString=port 2> /dev/null)
    export JMX_PORT=$(expr $port + $JMX_PORT_OFFSET)

    # Get the max direct memory we will use.  This can't use GetConfig because
    # there may be multiple variables involved.

    export MAX_DIRECT_MEMORY=$(./bin/jexec peregrine.worker.GetMaxDirectMemory $args 2> /dev/null)
    result=$?

    if [ "$result" != "0" ]; then
        echo "Unable to determine max memory" 
        exit $result
    fi

    # no, we weren't running, so go ahead and startup.
    host=$(./bin/jexec peregrine.worker.GetConfig $args --getString=host 2> /dev/null)

    case $OUTPUT in

        none)
            stderr="/dev/null"
            stdout="/dev/null"
            ;;

        standard)
            stderr="/dev/stderr"
            stdout="/dev/stdout"
            ;;

        file)
            stderr="logs/peregrine-workerd-$host.err"
            stdout="logs/peregrine-workerd-$host.out"
            ;;

        *)
            echo "UNKNOWN output option: $OUTPUT" > /dev/stderr
            exit 1
            ;;

    esac

    echo "Running with max JVM memory $MAX_MEMORY and max direct memory $MAX_DIRECT_MEMORY and writing output to '$OUTPUT'"

    #export PROFILER_ENABLED_OSX=true

    # enable auto-restart so that the workerd will restart automatically.
    #
    # killall is auto-restarting this ...
    #
    #export AUTO_RESTART=true

    ./bin/jexec peregrine.worker.Main $args < /dev/null > $stdout 2> $stderr &
    pid=$!

    # now disable auto-restart or WaitForDaemon will never return.
    export AUTO_RESTART=false

    # now that we started the daemon, wait for it to startup... if it starts, great,
    # if not fail.
    ./bin/jexec peregrine.worker.WaitForDaemon --pid=$pid $args 2> /dev/null 
    result=$?

    exit $result

}

stop() {
    
    ./bin/jexec peregrine.worker.Main $args 2> /dev/null
    result=$?

    if [ "$result" != "0" ]; then
        echo "FAILED to stop daemon"
    fi

    exit $result

}

args=$@
shift $(expr $# - 1)
command=$1

case $command in

    start)
        start
        ;;

    stop)
        stop
        ;;

    restart)
        stop
        start
        ;;

    *)
        echo "ERROR: unknown command: $command" 
        exit 1
        ;;

esac
