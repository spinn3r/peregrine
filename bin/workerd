#!/bin/sh

# When true, always allow the existing daemon to work.
export YIELD_TO_EXISTING_DAEMON=true

# Determine how to handle stdout and stderr from the worker daemon.  
#
# none: (default) we write to /dev/null.
# 
# standard: write to standard out and standard err
#
# file: write to .err and .out files.

export OUTPUT=file

###
#
# when true we run numactl and bind to a specific CPU and node.
export ENABLE_NUMACTL=true

###
# Get the numactl config by running numactl --hardware and then looking at the distribution 
get_numactl_config() {

    # the concurrency we need to run with.
    concurrency=$1

    hardware=$(numactl --hardware |grep -E 'node [0-9]+ cpus' |grep -Eo '[0-9 ]+$' )

    node=0
    port=11112

    IFS=$'\n' 
    for line in $hardware; do

        # change the IFS so we can break up CPUs
        IFS=' '
        
        # the current CPU count in the cpu set.
        cpu_count=0
        
        # the named set of CPUs to execute on 
        cpu_set=""

        for cpu in $line; do

            if [ "$cpu_set" == "" ]; then
                cpu_set="$cpu"
            else
                cpu_set="$cpu_set,$cpu"
            fi

            cpu_count=`expr $cpu_count + 1`

            if [ $cpu_count == $concurrency ]; then
                echo "$port --membind=$node --cpubind=$cpu_set"

                cpu_count=0
                cpu_set=""

                port=`expr $port + 1`

            fi

        done

        #echo $line
        node=`expr $node + 1`

        # we need to reset the IFS now.
        IFS=$'\n' 

    done

}

start() {

    # first check if we are already running ...
    ./bin/jexec peregrine.worker.WaitForDaemon 2> /dev/null > /dev/null $args 
    result=$?

    # yup... we're up and running, so stop and return.
    if [ "$result" = "0" ] && [ "$YIELD_TO_EXISTING_DAEMON" = "true" ] ; then
        echo "Daemon was already up and listening."
        exit 0
    fi

    export MAX_MEMORY=$(./bin/jexec peregrine.worker.GetConfig $args --getString=maxMemory 2> /dev/null | tail -1)

    export CONCURRENCY=$(./bin/jexec peregrine.worker.GetConfig $args --getString=concurrency 2> /dev/null | tail -1)

    export PORT=$(./bin/jexec peregrine.worker.GetConfig $args --getString=port 2> /dev/null | tail -1)

    result=$?

    if [ "$result" != "0" ]; then
        echo "Unable to determine max memory" 
        exit $result
    fi

    # no, we weren't running, so go ahead and startup.
    host=$(./bin/jexec peregrine.worker.GetConfig $args --getString=host 2> /dev/null | tail -1)

    case $OUTPUT in

        none)
            stderr="/dev/null"
            stdout="/dev/null"
            ;;

        standard)
            stderr="/dev/stderr"
            stdout="/dev/stdout"
            ;;

        file)
            stderr="logs/peregrine-workerd-$host.err"
            stdout="logs/peregrine-workerd-$host.out"
            ;;

        *)
            echo "UNKNOWN output option: $OUTPUT" > /dev/stderr
            exit 1
            ;;

    esac

    echo "Running on $host with max JVM memory $MAX_MEMORY and max direct memory $MAX_DIRECT_MEMORY and writing output to '$OUTPUT'"

    export REPLACE_PROCESS=true

    #export PROFILER_ENABLED_OSX=true
    ./bin/jexec peregrine.worker.Main $args < /dev/null > $stdout 2> $stderr &

    pid=$!

    export REPLACE_PROCESS=false

    # now that we started the daemon, wait for it to startup... if it starts, great,
    # if not fail.
    ./bin/jexec peregrine.worker.WaitForDaemon --pid=$pid $args 2> /dev/null 
    result=$?

    exit $result

}

stop() {
    
    ./bin/jexec peregrine.worker.Main $args 2> /dev/null
    result=$?

    if [ "$result" != "0" ]; then
        echo "FAILED to stop daemon"
    fi

    exit $result

}

args=$@
shift $(expr $# - 1)
command=$1

case $command in

    start)
        start
        ;;

    stop)
        stop
        ;;

    restart)
        stop
        start
        ;;

    *)
        echo "ERROR: unknown command: $command" 
        exit 1
        ;;

esac
