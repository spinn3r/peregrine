<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_43) on Tue Jul 16 13:32:56 PDT 2013 -->
<TITLE>
mman (Peregrine 0.9.0 API)
</TITLE>

<META NAME="date" CONTENT="2013-07-16">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="mman (Peregrine 0.9.0 API)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/mman.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../peregrine/os/MappedFileWriter.html" title="class in peregrine.os"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../peregrine/os/Platform.html" title="class in peregrine.os"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?peregrine/os/mman.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="mman.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
peregrine.os</FONT>
<BR>
Class mman</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>peregrine.os.mman</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>mman</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../peregrine/os/mman.html#MAP_LOCKED">MAP_LOCKED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../peregrine/os/mman.html#MAP_PRIVATE">MAP_PRIVATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../peregrine/os/mman.html#MAP_SHARED">MAP_SHARED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../peregrine/os/mman.html#PROT_EXEC">PROT_EXEC</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../peregrine/os/mman.html#PROT_NONE">PROT_NONE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../peregrine/os/mman.html#PROT_READ">PROT_READ</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../peregrine/os/mman.html#PROT_WRITE">PROT_WRITE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../peregrine/os/mman.html#mman()">mman</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../peregrine/os/mman.html#main(java.lang.String[])">main</A></B>(java.lang.String[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.nio.ByteBuffer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../peregrine/os/mman.html#mincore(com.sun.jna.Pointer, long)">mincore</A></B>(com.sun.jna.Pointer&nbsp;addr,
        long&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return information about the VFS page cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../peregrine/os/mman.html#mlock(com.sun.jna.Pointer, long)">mlock</A></B>(com.sun.jna.Pointer&nbsp;addr,
      long&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mlock() and mlockall() respectively lock part or all of the calling
 process's virtual address space into RAM, preventing that memory from
 being paged to the swap area.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;com.sun.jna.Pointer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../peregrine/os/mman.html#mmap(long, int, int, int, long)">mmap</A></B>(long&nbsp;len,
     int&nbsp;prot,
     int&nbsp;flags,
     int&nbsp;fildes,
     long&nbsp;off)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mmap() creates a new mapping in the virtual address space of the calling
 process.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../peregrine/os/mman.html#munlock(com.sun.jna.Pointer, long)">munlock</A></B>(com.sun.jna.Pointer&nbsp;addr,
        long&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unlock the given region, throw an IOException if we fail.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../peregrine/os/mman.html#munmap(com.sun.jna.Pointer, long)">munmap</A></B>(com.sun.jna.Pointer&nbsp;addr,
       long&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The munmap() system call deletes the mappings for the specified address
 range, and causes further references to addresses within the range to
 generate invalid memory references.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="PROT_READ"><!-- --></A><H3>
PROT_READ</H3>
<PRE>
public static final int <B>PROT_READ</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#peregrine.os.mman.PROT_READ">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="PROT_WRITE"><!-- --></A><H3>
PROT_WRITE</H3>
<PRE>
public static final int <B>PROT_WRITE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#peregrine.os.mman.PROT_WRITE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="PROT_EXEC"><!-- --></A><H3>
PROT_EXEC</H3>
<PRE>
public static final int <B>PROT_EXEC</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#peregrine.os.mman.PROT_EXEC">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="PROT_NONE"><!-- --></A><H3>
PROT_NONE</H3>
<PRE>
public static final int <B>PROT_NONE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#peregrine.os.mman.PROT_NONE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MAP_SHARED"><!-- --></A><H3>
MAP_SHARED</H3>
<PRE>
public static final int <B>MAP_SHARED</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#peregrine.os.mman.MAP_SHARED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MAP_PRIVATE"><!-- --></A><H3>
MAP_PRIVATE</H3>
<PRE>
public static final int <B>MAP_PRIVATE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#peregrine.os.mman.MAP_PRIVATE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MAP_LOCKED"><!-- --></A><H3>
MAP_LOCKED</H3>
<PRE>
public static final int <B>MAP_LOCKED</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#peregrine.os.mman.MAP_LOCKED">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="mman()"><!-- --></A><H3>
mman</H3>
<PRE>
public <B>mman</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="mmap(long, int, int, int, long)"><!-- --></A><H3>
mmap</H3>
<PRE>
public static com.sun.jna.Pointer <B>mmap</B>(long&nbsp;len,
                                       int&nbsp;prot,
                                       int&nbsp;flags,
                                       int&nbsp;fildes,
                                       long&nbsp;off)
                                throws java.io.IOException</PRE>
<DL>
<DD>mmap() creates a new mapping in the virtual address space of the calling
 process. The starting address for the new mapping is specified in
 addr. The length argument specifies the length of the mapping.
 
 If addr is NULL, then the kernel chooses the address at which to create
 the mapping; this is the most portable method of creating a new
 mapping. If addr is not NULL, then the kernel takes it as a hint about
 where to place the mapping; on Linux, the mapping will be created at a
 nearby page boundary. The address of the new mapping is returned as the
 result of the call.
 
 The contents of a file mapping (as opposed to an anonymous mapping; see
 MAP_ANONYMOUS below), are initialized using length bytes starting at
 offset offset in the file (or other object) referred to by the file
 descriptor fd. offset must be a multiple of the page size as returned by
 sysconf(_SC_PAGE_SIZE).
 
 The prot argument describes the desired memory protection of the mapping
 (and must not conflict with the open mode of the file). It is either
 PROT_NONE or the bitwise OR of one or more of the following flags:
 
 PROT_EXEC
 
 Pages may be executed.
 
 PROT_READ Pages may be read.
 
 PROT_WRITE
 
 Pages may be written.
 
 PROT_NONE
 
 Pages may not be accessed.
 
 The flags argument determines whether updates to the mapping are visible
 to other processes mapping the same region, and whether updates are
 carried through to the underlying file. This behavior is determined by
 including exactly one of the following values in flags:
 
 MAP_SHARED
 
 Share this mapping. Updates to the mapping are visible to other processes
 that map this file, and are carried through to the underlying file. The
 file may not actually be updated until msync(2) or munmap() is called.
 
 MAP_PRIVATE
 
 Create a private copy-on-write mapping. Updates to the mapping are not
 visible to other processes mapping the same file, and are not carried
 through to the underlying file. It is unspecified whether changes made to
 the file after the mmap() call are visible in the mapped region.
 
 Both of these flags are described in POSIX.1-2001.
 
 In addition, zero or more of the following values can be ORed in flags:
 
 MAP_32BIT (since Linux 2.4.20, 2.6)
 
 Put the mapping into the first 2 Gigabytes of the process address
 space. This flag is only supported on x86-64, for 64-bit programs. It was
 added to allow thread stacks to be allocated somewhere in the first 2GB
 of memory, so as to improve context-switch performance on some early
 64-bit processors. Modern x86-64 processors no longer have this
 performance problem, so use of this flag is not required on those
 systems. The MAP_32BIT flag is ignored when MAP_FIXED is set.
 
 MAP_ANON
 
 Synonym for MAP_ANONYMOUS. Deprecated.
 
 MAP_ANONYMOUS
 
 The mapping is not backed by any file; its contents are initialized to
 zero. The fd and offset arguments are ignored; however, some
 implementations require fd to be -1 if MAP_ANONYMOUS (or MAP_ANON) is
 specified, and portable applications should ensure this. The use of
 MAP_ANONYMOUS in conjunction with MAP_SHARED is only supported on Linux
 since kernel 2.4.
 
 MAP_DENYWRITE
 
 This flag is ignored. (Long ago, it signaled that attempts to write to
 the underlying file should fail with ETXTBUSY. But this was a source of
 denial-of-service attacks.)
 
 MAP_EXECUTABLE
 
 This flag is ignored.
 
 MAP_FILE
 
 Compatibility flag. Ignored.
 
 MAP_FIXED
 
 Don't interpret addr as a hint: place the mapping at exactly that
 address. addr must be a multiple of the page size. If the memory region
 specified by addr and len overlaps pages of any existing mapping(s), then
 the overlapped part of the existing mapping(s) will be discarded. If the
 specified address cannot be used, mmap() will fail. Because requiring a
 fixed address for a mapping is less portable, the use of this option is
 discouraged.
 
 MAP_GROWSDOWN
 
 Used for stacks. Indicates to the kernel virtual memory system that the
 mapping should extend downward in memory.
 
 MAP_HUGETLB (since Linux 2.6.32)
 
 Allocate the mapping using "huge pages." See the kernel source file
 Documentation/vm/hugetlbpage.txt for further information.
 
 MAP_LOCKED (since Linux 2.5.37)
 
 Lock the pages of the mapped region into memory in the manner of
 mlock(2). This flag is ignored in older kernels.
 
 MAP_NONBLOCK (since Linux 2.5.46)
 
 Only meaningful in conjunction with MAP_POPULATE. Don't perform
 read-ahead: only create page tables entries for pages that are already
 present in RAM. Since Linux 2.6.23, this flag causes MAP_POPULATE to do
 nothing. One day the combination of MAP_POPULATE and MAP_NONBLOCK may be
 reimplemented.
 
 MAP_NORESERVE
 
 Do not reserve swap space for this mapping. When swap space is reserved,
 one has the guarantee that it is possible to modify the mapping. When
 swap space is not reserved one might get SIGSEGV upon a write if no
 physical memory is available. See also the discussion of the file
 /proc/sys/vm/overcommit_memory in proc(5). In kernels before 2.6, this
 flag only had effect for private writable mappings.
 
 MAP_POPULATE (since Linux 2.5.46) Populate (prefault) page tables for a
 mapping. For a file mapping, this causes read-ahead on the file. Later
 accesses to the mapping will not be blocked by page faults. MAP_POPULATE
 is only supported for private mappings since Linux 2.6.23.
 
 MAP_STACK (since Linux 2.6.27)
 
 Allocate the mapping at an address suitable for a process or thread
 stack. This flag is currently a no-op, but is used in the glibc threading
 implementation so that if some architectures require special treatment
 for stack allocations, support can later be transparently implemented for
 glibc.
 
 MAP_UNINITIALIZED (since Linux 2.6.33)
 
 Don't clear anonymous pages. This flag is intended to improve performance
 on embedded devices. This flag is only honored if the kernel was
 configured with the CONFIG_
 
 MMAP_ALLOW_UNINITIALIZED option. Because of the security implications,
 that option is normally enabled only on embedded devices (i.e., devices
 where one has complete control of the contents of user memory).
 
 Of the above flags, only MAP_FIXED is specified in POSIX.1-2001. However,
 most systems also support MAP_ANONYMOUS (or its synonym MAP_ANON).
 
 Some systems document the additional flags MAP_AUTOGROW, MAP_AUTORESRV,
 MAP_COPY, and MAP_LOCAL.
 
 Memory mapped by mmap() is preserved across fork(2), with the same
 attributes.
 
 A file is mapped in multiples of the page size. For a file that is not a
 multiple of the page size, the remaining memory is zeroed when mapped,
 and writes to that region are not written out to the file. The effect of
 changing the size of the underlying file of a mapping on the pages that
 correspond to added or removed regions of the file is unspecified.

 
 Return Value
 
 On success, mmap() returns a pointer to the mapped area. On error, the
 value MAP_FAILED (that is, (void *) -1) is returned, and errno is set
 appropriately. On success, munmap() returns 0, on failure -1, and errno
 is set (probably to EINVAL).
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="munmap(com.sun.jna.Pointer, long)"><!-- --></A><H3>
munmap</H3>
<PRE>
public static int <B>munmap</B>(com.sun.jna.Pointer&nbsp;addr,
                         long&nbsp;len)
                  throws java.io.IOException</PRE>
<DL>
<DD>The munmap() system call deletes the mappings for the specified address
 range, and causes further references to addresses within the range to
 generate invalid memory references. The region is also automatically
 unmapped when the process is terminated. On the other hand, closing the
 file descriptor does not unmap the region.
 
 The address addr must be a multiple of the page size. All pages
 containing a part of the indicated range are unmapped, and subsequent
 references to these pages will generate SIGSEGV. It is not an error if
 the indicated range does not contain any mapped pages.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="mlock(com.sun.jna.Pointer, long)"><!-- --></A><H3>
mlock</H3>
<PRE>
public static void <B>mlock</B>(com.sun.jna.Pointer&nbsp;addr,
                         long&nbsp;len)
                  throws java.io.IOException</PRE>
<DL>
<DD>mlock() and mlockall() respectively lock part or all of the calling
 process's virtual address space into RAM, preventing that memory from
 being paged to the swap area. munlock() and munlockall() perform the
 converse operation, respectively unlocking part or all of the calling
 process's virtual address space, so that pages in the specified virtual
 address range may once more to be swapped out if required by the kernel
 memory manager. Memory locking and unlocking are performed in units of
 whole pages.
 
 mlock() and munlock()
 
 mlock() locks pages in the address range starting at addr and continuing
 for len bytes. All pages that contain a part of the specified address
 range are guaranteed to be resident in RAM when the call returns
 successfully; the pages are guaranteed to stay in RAM until later
 unlocked.
 
 munlock() unlocks pages in the address range starting at addr and
 continuing for len bytes. After this call, all pages that contain a part
 of the specified memory range can be moved to external swap space again
 by the kernel.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="munlock(com.sun.jna.Pointer, long)"><!-- --></A><H3>
munlock</H3>
<PRE>
public static void <B>munlock</B>(com.sun.jna.Pointer&nbsp;addr,
                           long&nbsp;len)
                    throws java.io.IOException</PRE>
<DL>
<DD>Unlock the given region, throw an IOException if we fail.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="mincore(com.sun.jna.Pointer, long)"><!-- --></A><H3>
mincore</H3>
<PRE>
public static java.nio.ByteBuffer <B>mincore</B>(com.sun.jna.Pointer&nbsp;addr,
                                          long&nbsp;len)
                                   throws java.io.IOException</PRE>
<DL>
<DD>Return information about the VFS page cache.  Specifically if given pages
 are cached.  This method is fast, even or a large file.  About 1ms for a
 500MB file on Linux.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>addr</CODE> - The pointer in memory of the mmap region as returned from mmap.<DD><CODE>len</CODE> - The length of the file for which we want page cache information.
<DT><B>Returns:</B><DD>a ByteBuffer where the offset is true if the given page is cached.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="main(java.lang.String[])"><!-- --></A><H3>
main</H3>
<PRE>
public static void <B>main</B>(java.lang.String[]&nbsp;args)
                 throws java.lang.Exception</PRE>
<DL>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/mman.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../peregrine/os/MappedFileWriter.html" title="class in peregrine.os"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../peregrine/os/Platform.html" title="class in peregrine.os"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?peregrine/os/mman.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="mman.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
Copyright &copy; 2011 Kevin Burton. All Rights Reserved.
</BODY>
</HTML>
